"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var core_1 = require('@angular/core');
var ModalInstanceStack_1 = require('../framework/ModalInstanceStack');
var ModalConfig_1 = require('../models/ModalConfig');
var ModalDialogInstance_1 = require('../models/ModalDialogInstance');
var modalBackdrop_1 = require('../components/modalBackdrop');
var presets_1 = require('../presets');
var _stack = new ModalInstanceStack_1.ModalInstanceStack();
var ModalCompileConfig = (function () {
    function ModalCompileConfig(component, bindings) {
        this.component = component;
        this.bindings = bindings;
    }
    return ModalCompileConfig;
}());
exports.ModalCompileConfig = ModalCompileConfig;
var Modal = (function () {
    function Modal(_cr, _renderer, defaultConfig) {
        // The Modal class should be an application wide service (i.e: singleton).
        // This will run once in most applications...
        // If the user provides a ModalConfig instance to the DI,
        // the custom config will be the default one.
        this._cr = _cr;
        this._renderer = _renderer;
        Object.defineProperty(this, 'config', {
            configurable: false,
            enumerable: true,
            value: (defaultConfig)
                ? ModalConfig_1.ModalConfig.makeValid(defaultConfig) : ModalConfig_1.ModalConfig.makeValid(new ModalConfig_1.ModalConfig()),
            writable: false
        });
    }
    Modal.prototype.alert = function () {
        return new presets_1.OneButtonPreset(this, { isBlocking: false });
    };
    Modal.prototype.prompt = function () {
        return new presets_1.OneButtonPreset(this, { isBlocking: true, keyboard: null });
    };
    Modal.prototype.confirm = function () {
        return new presets_1.TwoButtonPreset(this, { isBlocking: true, keyboard: null });
    };
    /**
     * Opens a modal window blocking the whole screen.
     * @param component The angular Component to render as modal.
     * @param bindings Resolved providers that will inject into the component provided.
     * @param config A Modal Configuration object.
     * @returns {Promise<ModalDialogInstance>}
     */
    Modal.prototype.open = function (component, bindings, config) {
        return this.openInside(component, this.defaultViewContainer, bindings, config);
    };
    /**
     * Opens a modal window inside an existing component.
     * @param component The angular Component to render as modal.
     * @param viewContainer The viewContainer to block using the modal.
     * @param bindings Resolved providers that will inject into the component provided.
     * @param config A Modal Configuration object.
     * @returns {Promise<ModalDialogInstance>}
     */
    Modal.prototype.openInside = function (component, viewContainer, bindings, config) {
        config = (config) ? ModalConfig_1.ModalConfig.makeValid(config, this.config) : this.config;
        var dialog = new ModalDialogInstance_1.ModalDialogInstance(config);
        var compileConfig = new ModalCompileConfig(component, bindings || []);
        dialog.inElement = viewContainer !== this.defaultViewContainer;
        var dialogBindings = core_1.ReflectiveInjector.resolve([
            new core_1.Provider(Modal, { useValue: this }),
            new core_1.Provider(ModalDialogInstance_1.ModalDialogInstance, { useValue: dialog }),
            new core_1.Provider(ModalCompileConfig, { useValue: compileConfig })
        ]);
        return this.createBackdrop(viewContainer, dialogBindings, dialog.inElement)
            .then(function (backdropRef) {
            // killing the root (backdrop) will cascade automatically.
            dialog.destroy = function () { return backdropRef.destroy(); };
            _stack.pushManaged(dialog);
            return dialog;
        });
    };
    Modal.prototype.stackPosition = function (mInstance) {
        return _stack.indexOf(mInstance);
    };
    Object.defineProperty(Modal.prototype, "stackLength", {
        get: function () {
            return _stack.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates backdrop element.
     * @param  viewContainer The viewContainer to block using the modal.
     * @param  bindings Resolved providers, must contain the ModalDialogInstance
     *         instance for this backdrop.
     * @param  attachToBody Attach to body or leave in the original view of the viewContainer.
     * @returns {Promise<ComponentRef>}
     */
    Modal.prototype.createBackdrop = function (viewContainer, bindings, attachToBody) {
        var _this = this;
        return this._cr.resolveComponent(modalBackdrop_1.ModalBackdrop)
            .then(function (cmpFactory) {
            var ctxInjector = viewContainer.parentInjector;
            var childInjector = Array.isArray(bindings) && bindings.length > 0 ?
                core_1.ReflectiveInjector.fromResolvedProviders(bindings, ctxInjector) : ctxInjector;
            return viewContainer.createComponent(cmpFactory, viewContainer.length, childInjector);
        })
            .then(function (cmpRef) {
            if (attachToBody) {
                _this._renderer.invokeElementMethod(viewContainer.element.nativeElement, 'appendChild', [cmpRef.hostView.rootNodes[0]]);
            }
            else {
                document.body.appendChild(cmpRef.hostView.rootNodes[0]);
            }
            return cmpRef;
        });
    };
    Modal = __decorate([
        core_1.Injectable(),
        __param(2, core_1.Optional()), 
        __metadata('design:paramtypes', [core_1.ComponentResolver, core_1.Renderer, ModalConfig_1.ModalConfig])
    ], Modal);
    return Modal;
}());
exports.Modal = Modal;
exports.MODAL_PROVIDERS = [
    new core_1.Provider(Modal, { useClass: Modal }),
    new core_1.Provider(ModalConfig_1.ModalConfig, { useValue: new ModalConfig_1.ModalConfig('lg', true, 27) })
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9hbmd1bGFyMi1tb2RhbC9wcm92aWRlcnMvTW9kYWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLHFCQVdPLGVBQWUsQ0FBQyxDQUFBO0FBRXZCLG1DQUFpQyxpQ0FBaUMsQ0FBQyxDQUFBO0FBQ25FLDRCQUEwQix1QkFBdUIsQ0FBQyxDQUFBO0FBQ2xELG9DQUFrQywrQkFBK0IsQ0FBQyxDQUFBO0FBQ2xFLDhCQUE0Qiw2QkFBNkIsQ0FBQyxDQUFBO0FBQzFELHdCQUErQyxZQUFZLENBQUMsQ0FBQTtBQUU1RCxJQUFNLE1BQU0sR0FBRyxJQUFJLHVDQUFrQixFQUFFLENBQUM7QUFFeEM7SUFDSSw0QkFBbUIsU0FBZSxFQUFTLFFBQXNDO1FBQTlELGNBQVMsR0FBVCxTQUFTLENBQU07UUFBUyxhQUFRLEdBQVIsUUFBUSxDQUE4QjtJQUFHLENBQUM7SUFDekYseUJBQUM7QUFBRCxDQUFDLEFBRkQsSUFFQztBQUZZLDBCQUFrQixxQkFFOUIsQ0FBQTtBQUdEO0lBVUksZUFBb0IsR0FBc0IsRUFDdEIsU0FBbUIsRUFDZixhQUEwQjtRQUM5QywwRUFBMEU7UUFDMUUsNkNBQTZDO1FBQzdDLHlEQUF5RDtRQUN6RCw2Q0FBNkM7UUFON0IsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDdEIsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQU9uQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQU87WUFDdkMsWUFBWSxFQUFFLEtBQUs7WUFDbkIsVUFBVSxFQUFFLElBQUk7WUFDaEIsS0FBSyxFQUFFLENBQUMsYUFBYSxDQUFDO2tCQUNoQix5QkFBVyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsR0FBRyx5QkFBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLHlCQUFXLEVBQUUsQ0FBQztZQUNyRixRQUFRLEVBQUUsS0FBSztT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QUksRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQUMsQ0FBQztDQUN6RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBSZWZsZWN0aXZlSW5qZWN0b3IsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBQcm92aWRlcixcbiAgICBJbmplY3RhYmxlLFxuICAgIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyLFxuICAgIENvbXBvbmVudFJlc29sdmVyLFxuICAgIE9wdGlvbmFsLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBSZW5kZXJlcixcbiAgICBUeXBlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge01vZGFsSW5zdGFuY2VTdGFja30gZnJvbSAnLi4vZnJhbWV3b3JrL01vZGFsSW5zdGFuY2VTdGFjayc7XG5pbXBvcnQge01vZGFsQ29uZmlnfSBmcm9tICcuLi9tb2RlbHMvTW9kYWxDb25maWcnO1xuaW1wb3J0IHtNb2RhbERpYWxvZ0luc3RhbmNlfSBmcm9tICcuLi9tb2RlbHMvTW9kYWxEaWFsb2dJbnN0YW5jZSc7XG5pbXBvcnQge01vZGFsQmFja2Ryb3B9IGZyb20gJy4uL2NvbXBvbmVudHMvbW9kYWxCYWNrZHJvcCc7XG5pbXBvcnQge09uZUJ1dHRvblByZXNldCwgVHdvQnV0dG9uUHJlc2V0fSBmcm9tICcuLi9wcmVzZXRzJztcblxuY29uc3QgX3N0YWNrID0gbmV3IE1vZGFsSW5zdGFuY2VTdGFjaygpO1xuXG5leHBvcnQgY2xhc3MgTW9kYWxDb21waWxlQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgY29tcG9uZW50OiBUeXBlLCBwdWJsaWMgYmluZGluZ3M6IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyW10pIHt9XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb2RhbCB7XG4gICAgLyoqXG4gICAgICogQSBEZWZhdWx0IHZpZXcgY29udGFpbmVyIHJlZiwgdXN1YWxseSB0aGUgYXBwIHJvb3QgY29udGFpbmVyIHJlZi5cbiAgICAgKiBNYWtlIHN1cmUgbm90IHRvIHByb3ZpZGUgc29tZXRoaW5nIHRoYXQgbWlnaHQgZ2V0IGRlc3Ryb3llZCwgaXQgd2lsbCBkZXN0cm95IHRoZSBtb2RhbHMgdG9vLlxuICAgICAqIFRoZSBjb250YWluZXIgaXMgdXNlZCBhcyBsb2dpY2FsIHZpZXcgaG9sZGVyLCBlbGVtZW50cyBtaWdodCBiZSBtb3ZlZC5cbiAgICAgKiBIYXMgdG8gYmUgc2V0IG1hbnVhbGx5IHVudGlsIHdlIGNhbiBmaW5kIGEgd2F5IHRvIGdldCBpdCBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0Vmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIGNvbmZpZzogTW9kYWxDb25maWc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jcjogQ29tcG9uZW50UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIGRlZmF1bHRDb25maWc6IE1vZGFsQ29uZmlnKSB7XG4gICAgICAgIC8vIFRoZSBNb2RhbCBjbGFzcyBzaG91bGQgYmUgYW4gYXBwbGljYXRpb24gd2lkZSBzZXJ2aWNlIChpLmU6IHNpbmdsZXRvbikuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBydW4gb25jZSBpbiBtb3N0IGFwcGxpY2F0aW9ucy4uLlxuICAgICAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlcyBhIE1vZGFsQ29uZmlnIGluc3RhbmNlIHRvIHRoZSBESSxcbiAgICAgICAgLy8gdGhlIGN1c3RvbSBjb25maWcgd2lsbCBiZSB0aGUgZGVmYXVsdCBvbmUuXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25maWcnLCA8YW55PntcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IChkZWZhdWx0Q29uZmlnKVxuICAgICAgICAgICAgICAgID8gTW9kYWxDb25maWcubWFrZVZhbGlkKGRlZmF1bHRDb25maWcpIDogTW9kYWxDb25maWcubWFrZVZhbGlkKG5ldyBNb2RhbENvbmZpZygpKSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhbGVydCgpOiBPbmVCdXR0b25QcmVzZXQge1xuICAgICAgICByZXR1cm4gbmV3IE9uZUJ1dHRvblByZXNldCh0aGlzLCA8YW55PnsgaXNCbG9ja2luZzogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgcHJvbXB0KCk6IE9uZUJ1dHRvblByZXNldCB7XG4gICAgICAgIHJldHVybiBuZXcgT25lQnV0dG9uUHJlc2V0KHRoaXMsIDxhbnk+eyBpc0Jsb2NraW5nOiB0cnVlLCBrZXlib2FyZDogbnVsbCB9KTtcbiAgICB9XG5cbiAgICBjb25maXJtKCk6IFR3b0J1dHRvblByZXNldCB7XG4gICAgICAgIHJldHVybiBuZXcgVHdvQnV0dG9uUHJlc2V0KHRoaXMsIDxhbnk+eyBpc0Jsb2NraW5nOiB0cnVlLCBrZXlib2FyZDogbnVsbCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIG1vZGFsIHdpbmRvdyBibG9ja2luZyB0aGUgd2hvbGUgc2NyZWVuLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIGFuZ3VsYXIgQ29tcG9uZW50IHRvIHJlbmRlciBhcyBtb2RhbC5cbiAgICAgKiBAcGFyYW0gYmluZGluZ3MgUmVzb2x2ZWQgcHJvdmlkZXJzIHRoYXQgd2lsbCBpbmplY3QgaW50byB0aGUgY29tcG9uZW50IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBjb25maWcgQSBNb2RhbCBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RhbERpYWxvZ0luc3RhbmNlPn1cbiAgICAgKi9cbiAgICBwdWJsaWMgb3Blbihjb21wb25lbnQ6IEZ1bmN0aW9uQ29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M6IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyW10sXG4gICAgICAgICAgICAgICAgY29uZmlnPzogTW9kYWxDb25maWcpOiBQcm9taXNlPE1vZGFsRGlhbG9nSW5zdGFuY2U+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbkluc2lkZShjb21wb25lbnQsIHRoaXMuZGVmYXVsdFZpZXdDb250YWluZXIsIGJpbmRpbmdzLCBjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgbW9kYWwgd2luZG93IGluc2lkZSBhbiBleGlzdGluZyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBUaGUgYW5ndWxhciBDb21wb25lbnQgdG8gcmVuZGVyIGFzIG1vZGFsLlxuICAgICAqIEBwYXJhbSB2aWV3Q29udGFpbmVyIFRoZSB2aWV3Q29udGFpbmVyIHRvIGJsb2NrIHVzaW5nIHRoZSBtb2RhbC5cbiAgICAgKiBAcGFyYW0gYmluZGluZ3MgUmVzb2x2ZWQgcHJvdmlkZXJzIHRoYXQgd2lsbCBpbmplY3QgaW50byB0aGUgY29tcG9uZW50IHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSBjb25maWcgQSBNb2RhbCBDb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RhbERpYWxvZ0luc3RhbmNlPn1cbiAgICAgKi9cbiAgICBwdWJsaWMgb3Blbkluc2lkZShjb21wb25lbnQ6IEZ1bmN0aW9uQ29uc3RydWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJbXSxcbiAgICAgICAgICAgICAgICAgICAgICBjb25maWc/OiBNb2RhbENvbmZpZyk6IFByb21pc2U8TW9kYWxEaWFsb2dJbnN0YW5jZT4ge1xuXG4gICAgICAgIGNvbmZpZyA9IChjb25maWcpID8gTW9kYWxDb25maWcubWFrZVZhbGlkKGNvbmZpZywgdGhpcy5jb25maWcpIDogdGhpcy5jb25maWc7XG5cbiAgICAgICAgY29uc3QgZGlhbG9nID0gbmV3IE1vZGFsRGlhbG9nSW5zdGFuY2UoY29uZmlnKTtcbiAgICAgICAgY29uc3QgY29tcGlsZUNvbmZpZyA9IG5ldyBNb2RhbENvbXBpbGVDb25maWcoY29tcG9uZW50LCBiaW5kaW5ncyB8fCBbXSk7XG4gICAgICAgIGRpYWxvZy5pbkVsZW1lbnQgPSB2aWV3Q29udGFpbmVyICE9PSB0aGlzLmRlZmF1bHRWaWV3Q29udGFpbmVyO1xuXG4gICAgICAgIGxldCBkaWFsb2dCaW5kaW5ncyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtcbiAgICAgICAgICAgIG5ldyBQcm92aWRlcihNb2RhbCwge3VzZVZhbHVlOiB0aGlzfSksIC8vIHVzZSBzYW1lIE1vZGFsIGluc3RhbmNlXG4gICAgICAgICAgICBuZXcgUHJvdmlkZXIoTW9kYWxEaWFsb2dJbnN0YW5jZSwge3VzZVZhbHVlOiBkaWFsb2d9KSxcbiAgICAgICAgICAgIG5ldyBQcm92aWRlcihNb2RhbENvbXBpbGVDb25maWcsIHt1c2VWYWx1ZTogY29tcGlsZUNvbmZpZ30pXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUJhY2tkcm9wKHZpZXdDb250YWluZXIsIGRpYWxvZ0JpbmRpbmdzLCBkaWFsb2cuaW5FbGVtZW50KVxuICAgICAgICAgICAgLnRoZW4oIChiYWNrZHJvcFJlZjogQ29tcG9uZW50UmVmPGFueT4pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBraWxsaW5nIHRoZSByb290IChiYWNrZHJvcCkgd2lsbCBjYXNjYWRlIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICAgICAgZGlhbG9nLmRlc3Ryb3kgPSAoKSA9PiBiYWNrZHJvcFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgX3N0YWNrLnB1c2hNYW5hZ2VkKGRpYWxvZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YWNrUG9zaXRpb24obUluc3RhbmNlOiBNb2RhbERpYWxvZ0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBfc3RhY2suaW5kZXhPZihtSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGdldCBzdGFja0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gX3N0YWNrLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB2aWV3Q29udGFpbmVyIFRoZSB2aWV3Q29udGFpbmVyIHRvIGJsb2NrIHVzaW5nIHRoZSBtb2RhbC5cbiAgICAgKiBAcGFyYW0gIGJpbmRpbmdzIFJlc29sdmVkIHByb3ZpZGVycywgbXVzdCBjb250YWluIHRoZSBNb2RhbERpYWxvZ0luc3RhbmNlIFxuICAgICAqICAgICAgICAgaW5zdGFuY2UgZm9yIHRoaXMgYmFja2Ryb3AuXG4gICAgICogQHBhcmFtICBhdHRhY2hUb0JvZHkgQXR0YWNoIHRvIGJvZHkgb3IgbGVhdmUgaW4gdGhlIG9yaWdpbmFsIHZpZXcgb2YgdGhlIHZpZXdDb250YWluZXIuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29tcG9uZW50UmVmPn1cbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZUJhY2tkcm9wKHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvQm9keTogYm9vbGVhbik6IFByb21pc2U8Q29tcG9uZW50UmVmPGFueT4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyLnJlc29sdmVDb21wb25lbnQoTW9kYWxCYWNrZHJvcClcbiAgICAgICAgICAgIC50aGVuKGNtcEZhY3RvcnkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eEluamVjdG9yID0gdmlld0NvbnRhaW5lci5wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEluamVjdG9yID0gQXJyYXkuaXNBcnJheShiaW5kaW5ncykgJiYgYmluZGluZ3MubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMoYmluZGluZ3MsIGN0eEluamVjdG9yKSA6IGN0eEluamVjdG9yO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGNtcEZhY3RvcnksIHZpZXdDb250YWluZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZEluamVjdG9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoY21wUmVmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNoVG9Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QoXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcHBlbmRDaGlsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBbY21wUmVmLmhvc3RWaWV3LnJvb3ROb2Rlc1swXV1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNtcFJlZi5ob3N0Vmlldy5yb290Tm9kZXNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY21wUmVmO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgTU9EQUxfUFJPVklERVJTID0gW1xuICAgIG5ldyBQcm92aWRlcihNb2RhbCwge3VzZUNsYXNzOiBNb2RhbH0pLFxuICAgIG5ldyBQcm92aWRlcihNb2RhbENvbmZpZywge3VzZVZhbHVlOiBuZXcgTW9kYWxDb25maWcoJ2xnJywgdHJ1ZSwgMjcpfSlcbl07XG4iXX0=